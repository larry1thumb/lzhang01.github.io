// this code was autogenerated from PJS
(function($p) {
    var Line = (function() {
        function Line() {
            var $this_1 = this;

            function $superCstr() {
                $p.extendClassChain($this_1)
            }
            $this_1.x1 = 0;
            $this_1.y1 = 0;
            $this_1.x2 = 0;
            $this_1.y2 = 0;
            $this_1.slope = 0;

            function update$0() {
                var trueY1 = 300.0 - $this_1.y1;
                var trueY2 = 300.0 - $this_1.y2;

                $this_1.slope = (trueY2 - trueY1) / (($this_1.x2 - $this_1.x1));
            }
            $p.addMethod($this_1, 'update', update$0, false);

            function $constr_4(p1x, p1y, p2x, p2y) {
                $superCstr();

                $this_1.x1 = p1x;
                $this_1.y1 = p1y;
                $this_1.x2 = p2x;
                $this_1.y2 = p2y;
                $this_1.slope = 0;
            }

            function $constr() {
                if (arguments.length === 4) {
                    $constr_4.apply($this_1, arguments);
                } else $superCstr();
            }
            $constr.apply(null, arguments);
        }
        return Line;
    })();
    $p.Line = Line;

    var i = 0;

    function setup() {
        $p.background(255);

        $p.size(300, 300);

        $p.smooth();
    }
    $p.setup = setup;
    setup = setup.bind($p);

    var SCREEN_SIZE = 800;
    var vertices = new $p.ArrayList();
    var upperHull = new $p.ArrayList();
    var temp = new $p.ArrayList();
    var temp2 = new $p.ArrayList();
    var lowerHull = new $p.ArrayList();
    var lines = new $p.ArrayList();
    var ConvexHull = new $p.ArrayList();
    var medianX = 0;
    var pmin = new $p.PVector();
    var pmax = new $p.PVector();
    var medianSlope = 0;
    var numberOfVertices = 0;
    var upperVertices = 0;
    var lowerVertices = 0;
    var control = 0;
    var indexMax = 0;
    var bridgeFound = 0;

    function draw() {
        if (control == 0) {
            for (var i = 0; i < numberOfVertices; ++i) {
                $p.strokeWeight(5.0);
                var p = vertices.get(i);
                $p.point(p.x, p.y);
            }
        } else {
            $p.background(255);
        }
    }
    $p.draw = draw;
    draw = draw.bind($p);

    function mouseClicked() {
        if ($p.mouseButton == $p.LEFT && control == 0) {
            addPoint($p.mouseX, $p.mouseY);
        }
        $p.redraw();
    }
    $p.mouseClicked = mouseClicked;
    mouseClicked = mouseClicked.bind($p);

    function addPoint(x, y) {
        var newPoint = new $p.PVector(x, y);
        vertices.add(newPoint);
        ++numberOfVertices;
    }
    $p.addPoint = addPoint;
    addPoint = addPoint.bind($p);

    function keyPressed() {
        if (control == 0 && $p.keyCode == $p.ENTER) {
            $p.noLoop();
            splitHulls();
            ++control;
            return;
        }
        if (control == 1 && $p.keyCode == $p.ENTER) {
            medianX = findXMedian(upperHull, upperVertices);
            ++control;
            return;
        }
        if (control == 2 && $p.keyCode == $p.ENTER) {
            pairVertices(upperHull, upperVertices);
            medianSlope = findSlopeMedian();
            ++control;
            return;
        }
        if (control == 3 && $p.keyCode == $p.ENTER) {
            indexMax = sweepLines();
            testSlope(indexMax);
            ++control;
            return;
        }
        if (control == 4 && $p.keyCode == $p.ENTER) {
            removeNonBridge(indexMax);
            lines.clear();
            if (bridgeFound == 1) {
                ++control;
                ++control;
                return;
            } else {
                ++control;
                return;
            }
        }
        if (control == 5 && $p.keyCode == $p.ENTER) {
            $p.redraw();
            $p.stroke(160, 82, 45);
            $p.strokeWeight(2.0);
            $p.line(pmin.x, pmin.y, pmax.x, pmax.y);
            $p.stroke(255, 165, 0);
            $p.line(medianX, 0, medianX, 300);
            $p.stroke(0, 0, 0);
            $p.strokeWeight(5.0);
            for (var i = 0; i < lowerVertices; ++i) {
                var p1 = lowerHull.get(i);
                $p.point(p1.x, p1.y);
            }
            for (var i = 0; i < upperVertices; ++i) {
                var p1 = upperHull.get(i);
                $p.point(p1.x, p1.y);
            }
            control = 2;
            return;
        }
        if (control == 6 && $p.keyCode == $p.ENTER) {
            $p.redraw();
            $p.stroke(160, 82, 45);
            $p.strokeWeight(2.0);
            $p.line(pmin.x, pmin.y, pmax.x, pmax.y);
            $p.stroke(0, 0, 0);
            $p.strokeWeight(5.0);
            var numVertices = vertices.size();
            for (var i = 0; i < numVertices; ++i) {
                var p1 = vertices.get(i);
                $p.point(p1.x, p1.y);
            }
            $p.strokeWeight(2.0);
            var numConvexPoints = ConvexHull.size();
            sortX(ConvexHull);
            for (var i = 0; i < numConvexPoints - 1; ++i) {
                var p1 = ConvexHull.get(i);
                var p2 = ConvexHull.get(i + 1);
                $p.line(p1.x, p1.y, p2.x, p2.y);
            }++control;
            return;
        }
        if (control == 7 && $p.keyCode == $p.ENTER) {
            upperHull.clear();
            splitHulls();
            var numPoints = upperHull.size();
            for (var i = 0; i < numPoints; ++i) {
                var p1 = upperHull.get(i);
                var test = contains(p1);
                if (test == true) {
                    $p.strokeWeight(30.0);
                    $p.point(299, 299);
                    upperHull.remove(i);
                    i--;
                    numPoints--;
                }
            }
            $p.redraw();
            $p.stroke(160, 82, 45);
            $p.strokeWeight(2.0);
            $p.line(pmin.x, pmin.y, pmax.x, pmax.y);
            $p.stroke(0, 0, 0);
            $p.strokeWeight(5.0);
            var numUPoints = upperHull.size();
            var numLPoints = lowerHull.size();
            for (var i = 0; i < numUPoints; ++i) {
                var p1 = upperHull.get(i);
                $p.point(p1.x, p1.y);
            }
            for (var i = 0; i < numLPoints; ++i) {
                var p1 = lowerHull.get(i);
                $p.stroke(192, 192, 192);
                $p.point(p1.x, p1.y);
            }
            $p.stroke(0, 0, 0);
            $p.strokeWeight(2.0);
            var numConvexPoints = ConvexHull.size();
            for (var i = 0; i < numConvexPoints - 1; ++i) {
                var p1 = ConvexHull.get(i);
                var p2 = ConvexHull.get(i + 1);
                $p.line(p1.x, p1.y, p2.x, p2.y);
            }++control;
            return;
        }
        if (control == 8 && $p.keyCode == $p.ENTER) {
            var numPoints = upperHull.size();
            for (var i = 0; i < numPoints; ++i) {
                var p1 = upperHull.get(i);
                if (p1.x < medianX) {
                    temp.add(p1);
                } else {
                    temp2.add(p1);
                }
            }
            var tempSize = temp.size();
            var temp2Size = temp2.size();
            findXMedian(temp, tempSize);
            findXMedian(temp2, temp2Size);
        }
    }
    $p.keyPressed = keyPressed;
    keyPressed = keyPressed.bind($p);

    function testSlope(index) {
        var p1 = upperHull.get(index);
        $p.strokeWeight(10.0);
        $p.stroke(0, 0, 0);
        $p.point(p1.x, p1.y);
    }
    $p.testSlope = testSlope;
    testSlope = testSlope.bind($p);

    function removeNonBridge(index) {
        var p1 = upperHull.get(index);
        var slope = 0;
        var numLines = lines.size();
        for (var i = 0; i < numLines; ++i) {
            var l1 = lines.get(i);
            if ((p1.x == l1.x1 && p1.y == l1.y1) || (p1.x == l1.x2 && p1.y == l1.y2)) {
                slope = l1.slope;
                if (medianSlope == slope) {
                    if ((l1.x1 <= medianX && l1.x2 >= medianX) || (l1.x2 <= medianX && l1.x1 >= medianX)) {
                        var newLine = new Line(l1.x1, l1.y1, l1.x2, l1.y2);
                        newLine.update();
                        var cp1 = new $p.PVector(l1.x1, l1.y1);
                        var cp2 = new $p.PVector(l1.x2, l1.y2);
                        ConvexHull.add(cp1);
                        ConvexHull.add(cp2);
                        bridgeFound = 1;
                        return;
                    }
                }
                break;
            }
        }
        var mid = $p.floor(numLines / 2);
        if (p1.x < medianX) {
            for (var i = mid; i < numLines; ++i) {
                removePoint(i, 0);
            }
        } else {
            for (var i = 0; i <= mid; ++i) {
                removePoint(i, 1);
            }
        }
    }
    $p.removeNonBridge = removeNonBridge;
    removeNonBridge = removeNonBridge.bind($p);

    function removePoint(i, side) {
        var l1 = lines.get(i);
        var x = 0,
            y = 0;
        if (l1.x1 > l1.x2) {
            if (side == 0) {
                x = l1.x2;
                y = l1.y2;
            } else {
                x = l1.x1;
                y = l1.y1;
            }
        } else {
            if (side == 0) {
                x = l1.x1;
                y = l1.y1;
            } else {
                x = l1.x2;
                y = l1.y2;
            }
        }

        for (var j = 0; j < upperVertices; ++j) {
            var p1 = upperHull.get(j);
            if (x == p1.x && y == p1.y) {
                $p.strokeWeight(10.0);
                $p.stroke(255, 204, 255);
                $p.point(x, y);
                upperHull.remove(j);
                --upperVertices;
                return;
            }
        }
    }
    $p.removePoint = removePoint;
    removePoint = removePoint.bind($p);

    function splitHulls() {
        sortX(vertices);
        var numVertices = vertices.size();
        pmin = vertices.get(0);
        pmax = vertices.get(numVertices - 1);
        ConvexHull.add(pmin);
        ConvexHull.add(pmax);
        $p.stroke(160, 82, 45);
        $p.strokeWeight(2.0);
        $p.line(pmin.x, pmin.y, pmax.x, pmax.y);
        for (var i = 0; i < numVertices; ++i) {
            var p1 = vertices.get(i);
            var newPoint = new $p.PVector(p1.x, p1.y);
            var check = ((pmax.x - pmin.x) * (p1.y - pmin.y) - (pmax.y - pmin.y) * (p1.x - pmin.x));
            if (check <= 0) {
                upperHull.add(newPoint);
                ++upperVertices;
            } else {
                lowerHull.add(newPoint);
                ++lowerVertices;
            }
        }
    }
    $p.splitHulls = splitHulls;
    splitHulls = splitHulls.bind($p);

    function findXMedian(hull, numVertices) {
        var med = 0;
        sortX(hull);
        var mid = $p.floor(numVertices / 2);
        if (numVertices % 2 != 0) {
            var p1 = hull.get(mid);
            med = p1.x;
        } else {
            var p1 = hull.get(mid);
            var p2 = hull.get(mid - 1);
            med = (p1.x + p2.x) / 2.0;
        }
        $p.strokeWeight(2.0);
        $p.stroke(255, 165, 0);
        $p.line(med, 0, med, 300);
        return med;
    }
    $p.findXMedian = findXMedian;
    findXMedian = findXMedian.bind($p);

    function pairVertices(hull, numVertices) {
        for (var i = 0; i < $p.floor(numVertices / 2); ++i) {
            var p1 = hull.get(i);
            var p2 = hull.get(numVertices - i - 1);
            $p.strokeWeight(1.0);
            $p.stroke(0, 0, 255);
            $p.line(p1.x, p1.y, p2.x, p2.y);
            var newLine = new Line(p1.x, p1.y, p2.x, p2.y);
            newLine.update();
            lines.add(newLine);
        }
    }
    $p.pairVertices = pairVertices;
    pairVertices = pairVertices.bind($p);

    function findSlopeMedian() {
        var medSlope = 0;
        sortSlope(lines);
        var numLines = lines.size();
        var mid = $p.floor(numLines / 2);
        for (var i = 0; i < numLines; ++i) {
            var l1 = lines.get(i);
            if (i < mid) {
                $p.stroke(0, 255, 0);
            } else if (i == mid) {
                $p.stroke(0, 0, 255);
                medSlope = l1.slope;
            } else {
                $p.stroke(255, 0, 0);
            }
            $p.line(l1.x1, l1.y1, l1.x2, l1.y2);
        }
        return medSlope;
    }
    $p.findSlopeMedian = findSlopeMedian;
    findSlopeMedian = findSlopeMedian.bind($p);

    function sweepLines() {
        var index = 0;
        var theta = $p.atan(medianSlope);
        var c = $p.cos(theta);
        var s = $p.sin(theta);
        var maxY = 0.0;
        for (var i = 0; i < upperVertices; ++i) {
            var p1 = upperHull.get(i);
            var y1 = -p1.x * s + (300.0 - p1.y) * c;
            if (y1 > maxY) {
                maxY = y1;
                index = i;
            }
        }
        return index;
    }
    $p.sweepLines = sweepLines;
    sweepLines = sweepLines.bind($p);

    function swap(list, a, b) {
        var tmp = list.get(a);
        list.set(a, list.get(b));
        list.set(b, tmp);
    }
    $p.swap = swap;
    swap = swap.bind($p);

    function partitionY(list, left, right) {
        var pivotIndex = $p.floor((left + right) / 2);
        var pivotValue = list.get(pivotIndex);
        var value = pivotValue.y;
        swap(list, pivotIndex, right);

        var storedIndex = left;
        for (var i = left; i < right; ++i) {
            var currentValue = list.get(i);
            var curVal = currentValue.y;
            if (curVal < value) {
                swap(list, storedIndex, i);
                ++storedIndex;
            }
        }
        swap(list, right, storedIndex);
        return storedIndex;
    }
    $p.partitionY = partitionY;
    partitionY = partitionY.bind($p);

    function QuickSortY(list, left, right) {
        if (left < right) {
            var pivot = partitionY(list, left, right);
            QuickSortY(list, left, pivot - 1);
            QuickSortY(list, pivot + 1, right);
        }
        return list;
    }
    $p.QuickSortY = QuickSortY;
    QuickSortY = QuickSortY.bind($p);

    function sortY(list) {
        return QuickSortY(list, 0, list.size() - 1);
    }
    $p.sortY = sortY;
    sortY = sortY.bind($p);

    function partitionX(list, left, right) {
        var pivotIndex = $p.floor((left + right) / 2);
        var pivotValue = list.get(pivotIndex);
        var value = pivotValue.x;
        swap(list, pivotIndex, right);

        var storedIndex = left;
        for (var i = left; i < right; ++i) {
            var currentValue = list.get(i);
            var curVal = currentValue.x;
            if (curVal < value) {
                swap(list, storedIndex, i);
                ++storedIndex;
            }
        }
        swap(list, right, storedIndex);
        return storedIndex;
    }
    $p.partitionX = partitionX;
    partitionX = partitionX.bind($p);

    function QuickSortX(list, left, right) {
        if (left < right) {
            var pivot = partitionX(list, left, right);
            QuickSortX(list, left, pivot - 1);
            QuickSortX(list, pivot + 1, right);
        }
        return list;
    }
    $p.QuickSortX = QuickSortX;
    QuickSortX = QuickSortX.bind($p);

    function sortX(list) {
        return QuickSortX(list, 0, list.size() - 1);
    }
    $p.sortX = sortX;
    sortX = sortX.bind($p);

    function partitionSlope(list, left, right) {
        var pivotIndex = $p.floor((left + right) / 2);
        var pivotValue = list.get(pivotIndex);
        var value = pivotValue.slope;
        swapLine(list, pivotIndex, right);

        var storedIndex = left;
        for (var i = left; i < right; ++i) {
            var currentValue = list.get(i);
            var curVal = currentValue.slope;
            if (curVal < value) {
                swap(list, storedIndex, i);
                ++storedIndex;
            }
        }
        swap(list, right, storedIndex);
        return storedIndex;
    }
    $p.partitionSlope = partitionSlope;
    partitionSlope = partitionSlope.bind($p);

    function QuickSortSlope(list, left, right) {
        if (left < right) {
            var pivot = partitionSlope(list, left, right);
            QuickSortSlope(list, left, pivot - 1);
            QuickSortSlope(list, pivot + 1, right);
        }
        return list;
    }
    $p.QuickSortSlope = QuickSortSlope;
    QuickSortSlope = QuickSortSlope.bind($p);

    function sortSlope(list) {
        return QuickSortSlope(list, 0, list.size() - 1);
    }
    $p.sortSlope = sortSlope;
    sortSlope = sortSlope.bind($p);

    function swapLine(list, a, b) {
        var tmp = list.get(a);
        list.set(a, list.get(b));
        list.set(b, tmp);
    }
    $p.swapLine = swapLine;
    swapLine = swapLine.bind($p);

    function contains(test) {
        var i = 0;
        var j = 0;
        var result = false;
        var numCPoints = ConvexHull.size();
        for (i = 0, j = numCPoints - 1; i < numCPoints; j = i++) {
            var p1 = ConvexHull.get(i);
            var p2 = ConvexHull.get(j);
            if (((p1.y > test.y) != (p2.y > test.y)) && (test.x < (p2.x - p1.x) * (test.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                result = !result;
            }
        }
        return result;
    }
    $p.contains = contains;
    contains = contains.bind($p);

})